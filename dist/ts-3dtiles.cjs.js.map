{"version":3,"file":"ts-3dtiles.cjs.js","sources":["../node_modules/iobuffer/src/text-encoding-polyfill.js","../node_modules/iobuffer/src/utf8.browser.ts","../node_modules/iobuffer/src/IOBuffer.ts"],"sourcesContent":["/*\n * Copyright 2017 Sam Thorogood. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\n(function(scope) {\n  'use strict';\n\n  // fail early\n  if (scope['TextEncoder'] && scope['TextDecoder']) {\n    return false;\n  }\n\n  /**\n   * @constructor\n   * @param {string=} utfLabel\n   */\n  function FastTextEncoder(utfLabel = 'utf-8') {\n    if (utfLabel !== 'utf-8') {\n      throw new RangeError(\n        `Failed to construct 'TextEncoder': The encoding label provided ('${utfLabel}') is invalid.`,\n      );\n    }\n  }\n\n  Object.defineProperty(FastTextEncoder.prototype, 'encoding', {\n    value: 'utf-8',\n  });\n\n  /**\n   * @param {string} string\n   * @param {{stream: boolean}=} options\n   * @return {!Uint8Array}\n   */\n  FastTextEncoder.prototype.encode = function(\n    string,\n    options = { stream: false },\n  ) {\n    if (options.stream) {\n      throw new Error(`Failed to encode: the 'stream' option is unsupported.`);\n    }\n\n    let pos = 0;\n    const len = string.length;\n    const out = [];\n\n    let at = 0; // output position\n    let tlen = Math.max(32, len + (len >> 1) + 7); // 1.5x size\n    let target = new Uint8Array((tlen >> 3) << 3); // ... but at 8 byte offset\n\n    while (pos < len) {\n      let value = string.charCodeAt(pos++);\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < len) {\n          const extra = string.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n        if (value >= 0xd800 && value <= 0xdbff) {\n          continue; // drop lone surrogate\n        }\n      }\n\n      // expand the buffer if we couldn't write 4 bytes\n      if (at + 4 > target.length) {\n        tlen += 8; // minimum extra\n        tlen *= 1.0 + (pos / string.length) * 2; // take 2x the remaining\n        tlen = (tlen >> 3) << 3; // 8 byte offset\n\n        const update = new Uint8Array(tlen);\n        update.set(target);\n        target = update;\n      }\n\n      if ((value & 0xffffff80) === 0) {\n        // 1-byte\n        target[at++] = value; // ASCII\n        continue;\n      } else if ((value & 0xfffff800) === 0) {\n        // 2-byte\n        target[at++] = ((value >> 6) & 0x1f) | 0xc0;\n      } else if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        target[at++] = ((value >> 12) & 0x0f) | 0xe0;\n        target[at++] = ((value >> 6) & 0x3f) | 0x80;\n      } else if ((value & 0xffe00000) === 0) {\n        // 4-byte\n        target[at++] = ((value >> 18) & 0x07) | 0xf0;\n        target[at++] = ((value >> 12) & 0x3f) | 0x80;\n        target[at++] = ((value >> 6) & 0x3f) | 0x80;\n      } else {\n        // FIXME: do we care\n        continue;\n      }\n\n      target[at++] = (value & 0x3f) | 0x80;\n    }\n\n    return target.slice(0, at);\n  };\n\n  /**\n   * @constructor\n   * @param {string=} utfLabel\n   * @param {{fatal: boolean}=} options\n   */\n  function FastTextDecoder(utfLabel = 'utf-8', options = { fatal: false }) {\n    if (utfLabel !== 'utf-8') {\n      throw new RangeError(\n        `Failed to construct 'TextDecoder': The encoding label provided ('${utfLabel}') is invalid.`,\n      );\n    }\n    if (options.fatal) {\n      throw new Error(\n        `Failed to construct 'TextDecoder': the 'fatal' option is unsupported.`,\n      );\n    }\n  }\n\n  Object.defineProperty(FastTextDecoder.prototype, 'encoding', {\n    value: 'utf-8',\n  });\n\n  Object.defineProperty(FastTextDecoder.prototype, 'fatal', { value: false });\n\n  Object.defineProperty(FastTextDecoder.prototype, 'ignoreBOM', {\n    value: false,\n  });\n\n  /**\n   * @param {(!ArrayBuffer|!ArrayBufferView)} buffer\n   * @param {{stream: boolean}=} options\n   */\n  FastTextDecoder.prototype.decode = function(\n    buffer,\n    options = { stream: false },\n  ) {\n    if (options['stream']) {\n      throw new Error(`Failed to decode: the 'stream' option is unsupported.`);\n    }\n\n    const bytes = new Uint8Array(buffer);\n    let pos = 0;\n    const len = bytes.length;\n    const out = [];\n\n    while (pos < len) {\n      const byte1 = bytes[pos++];\n      if (byte1 === 0) {\n        break; // NULL\n      }\n\n      if ((byte1 & 0x80) === 0) {\n        // 1-byte\n        out.push(byte1);\n      } else if ((byte1 & 0xe0) === 0xc0) {\n        // 2-byte\n        const byte2 = bytes[pos++] & 0x3f;\n        out.push(((byte1 & 0x1f) << 6) | byte2);\n      } else if ((byte1 & 0xf0) === 0xe0) {\n        const byte2 = bytes[pos++] & 0x3f;\n        const byte3 = bytes[pos++] & 0x3f;\n        out.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n      } else if ((byte1 & 0xf8) === 0xf0) {\n        const byte2 = bytes[pos++] & 0x3f;\n        const byte3 = bytes[pos++] & 0x3f;\n        const byte4 = bytes[pos++] & 0x3f;\n\n        // this can be > 0xffff, so possibly generate surrogates\n        let codepoint =\n          ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n        if (codepoint > 0xffff) {\n          // codepoint &= ~0x10000;\n          codepoint -= 0x10000;\n          out.push(((codepoint >>> 10) & 0x3ff) | 0xd800);\n          codepoint = 0xdc00 | (codepoint & 0x3ff);\n        }\n        out.push(codepoint);\n      } else {\n        // FIXME: we're ignoring this\n      }\n    }\n\n    return String.fromCharCode.apply(null, out);\n  };\n\n  scope['TextEncoder'] = FastTextEncoder;\n  scope['TextDecoder'] = FastTextDecoder;\n})(\n  typeof window !== 'undefined'\n    ? window\n    : typeof self !== 'undefined'\n    ? self\n    : this,\n);\n","// eslint-disable-next-line import/no-unassigned-import\nimport './text-encoding-polyfill';\n\nconst decoder = new TextDecoder('utf-8');\n\nexport function decode(bytes: Uint8Array): string {\n  return decoder.decode(bytes);\n}\n\nconst encoder = new TextEncoder();\n\nexport function encode(str: string): Uint8Array {\n  return encoder.encode(str);\n}\n","import { decode, encode } from './utf8';\n\nconst defaultByteLength = 1024 * 8;\n\ntype InputData = number | ArrayBufferLike | ArrayBufferView | IOBuffer | Buffer;\n\ninterface IOBufferOptions {\n  /**\n   * Ignore the first n bytes of the ArrayBuffer.\n   */\n  offset?: number;\n}\n\nexport class IOBuffer {\n  /**\n   * Reference to the internal ArrayBuffer object.\n   */\n  public buffer: ArrayBufferLike;\n\n  /**\n   * Byte length of the internal ArrayBuffer.\n   */\n  public byteLength: number;\n\n  /**\n   * Byte offset of the internal ArrayBuffer.\n   */\n  public byteOffset: number;\n\n  /**\n   * Byte length of the internal ArrayBuffer.\n   */\n  public length: number;\n\n  /**\n   * The current offset of the buffer's pointer.\n   */\n  public offset: number;\n\n  private lastWrittenByte: number;\n  private littleEndian: boolean;\n\n  private _data: DataView;\n  private _mark: number;\n  private _marks: number[];\n\n  /**\n   * @param data - The data to construct the IOBuffer with.\n   * If data is a number, it will be the new buffer's length<br>\n   * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>\n   * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,\n   * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.\n   * @param options\n   */\n  public constructor(\n    data: InputData = defaultByteLength,\n    options: IOBufferOptions = {},\n  ) {\n    let dataIsGiven = false;\n    if (typeof data === 'number') {\n      data = new ArrayBuffer(data);\n    } else {\n      dataIsGiven = true;\n      this.lastWrittenByte = data.byteLength;\n    }\n\n    const offset = options.offset ? options.offset >>> 0 : 0;\n    const byteLength = data.byteLength - offset;\n    let dvOffset = offset;\n    if (ArrayBuffer.isView(data) || data instanceof IOBuffer) {\n      if (data.byteLength !== data.buffer.byteLength) {\n        dvOffset = data.byteOffset + offset;\n      }\n      data = data.buffer;\n    }\n    if (dataIsGiven) {\n      this.lastWrittenByte = byteLength;\n    } else {\n      this.lastWrittenByte = 0;\n    }\n    this.buffer = data;\n    this.length = byteLength;\n    this.byteLength = byteLength;\n    this.byteOffset = dvOffset;\n    this.offset = 0;\n    this.littleEndian = true;\n    this._data = new DataView(this.buffer, dvOffset, byteLength);\n    this._mark = 0;\n    this._marks = [];\n  }\n\n  /**\n   * Checks if the memory allocated to the buffer is sufficient to store more\n   * bytes after the offset.\n   * @param byteLength - The needed memory in bytes.\n   * @returns `true` if there is sufficient space and `false` otherwise.\n   */\n  public available(byteLength = 1): boolean {\n    return this.offset + byteLength <= this.length;\n  }\n\n  /**\n   * Check if little-endian mode is used for reading and writing multi-byte\n   * values.\n   * @returns `true` if little-endian mode is used, `false` otherwise.\n   */\n  public isLittleEndian(): boolean {\n    return this.littleEndian;\n  }\n\n  /**\n   * Set little-endian mode for reading and writing multi-byte values.\n   */\n  public setLittleEndian(): this {\n    this.littleEndian = true;\n    return this;\n  }\n\n  /**\n   * Check if big-endian mode is used for reading and writing multi-byte values.\n   * @returns `true` if big-endian mode is used, `false` otherwise.\n   */\n  public isBigEndian(): boolean {\n    return !this.littleEndian;\n  }\n\n  /**\n   * Switches to big-endian mode for reading and writing multi-byte values.\n   */\n  public setBigEndian(): this {\n    this.littleEndian = false;\n    return this;\n  }\n\n  /**\n   * Move the pointer n bytes forward.\n   * @param n - Number of bytes to skip.\n   */\n  public skip(n = 1): this {\n    this.offset += n;\n    return this;\n  }\n\n  /**\n   * Move the pointer to the given offset.\n   * @param offset\n   */\n  public seek(offset: number): this {\n    this.offset = offset;\n    return this;\n  }\n\n  /**\n   * Store the current pointer offset.\n   * @see {@link IOBuffer#reset}\n   */\n  public mark(): this {\n    this._mark = this.offset;\n    return this;\n  }\n\n  /**\n   * Move the pointer back to the last pointer offset set by mark.\n   * @see {@link IOBuffer#mark}\n   */\n  public reset(): this {\n    this.offset = this._mark;\n    return this;\n  }\n\n  /**\n   * Push the current pointer offset to the mark stack.\n   * @see {@link IOBuffer#popMark}\n   */\n  public pushMark(): this {\n    this._marks.push(this.offset);\n    return this;\n  }\n\n  /**\n   * Pop the last pointer offset from the mark stack, and set the current\n   * pointer offset to the popped value.\n   * @see {@link IOBuffer#pushMark}\n   */\n  public popMark(): this {\n    const offset = this._marks.pop();\n    if (offset === undefined) {\n      throw new Error('Mark stack empty');\n    }\n    this.seek(offset);\n    return this;\n  }\n\n  /**\n   * Move the pointer offset back to 0.\n   */\n  public rewind(): this {\n    this.offset = 0;\n    return this;\n  }\n\n  /**\n   * Make sure the buffer has sufficient memory to write a given byteLength at\n   * the current pointer offset.\n   * If the buffer's memory is insufficient, this method will create a new\n   * buffer (a copy) with a length that is twice (byteLength + current offset).\n   * @param byteLength\n   */\n  public ensureAvailable(byteLength = 1): this {\n    if (!this.available(byteLength)) {\n      const lengthNeeded = this.offset + byteLength;\n      const newLength = lengthNeeded * 2;\n      const newArray = new Uint8Array(newLength);\n      newArray.set(new Uint8Array(this.buffer));\n      this.buffer = newArray.buffer;\n      this.length = this.byteLength = newLength;\n      this._data = new DataView(this.buffer);\n    }\n    return this;\n  }\n\n  /**\n   * Read a byte and return false if the byte's value is 0, or true otherwise.\n   * Moves pointer forward by one byte.\n   */\n  public readBoolean(): boolean {\n    return this.readUint8() !== 0;\n  }\n\n  /**\n   * Read a signed 8-bit integer and move pointer forward by 1 byte.\n   */\n  public readInt8(): number {\n    return this._data.getInt8(this.offset++);\n  }\n\n  /**\n   * Read an unsigned 8-bit integer and move pointer forward by 1 byte.\n   */\n  public readUint8(): number {\n    return this._data.getUint8(this.offset++);\n  }\n\n  /**\n   * Alias for {@link IOBuffer#readUint8}.\n   */\n  public readByte(): number {\n    return this.readUint8();\n  }\n\n  /**\n   * Read `n` bytes and move pointer forward by `n` bytes.\n   */\n  public readBytes(n = 1): Uint8Array {\n    const bytes = new Uint8Array(n);\n    for (let i = 0; i < n; i++) {\n      bytes[i] = this.readByte();\n    }\n    return bytes;\n  }\n\n  /**\n   * Read a 16-bit signed integer and move pointer forward by 2 bytes.\n   */\n  public readInt16(): number {\n    const value = this._data.getInt16(this.offset, this.littleEndian);\n    this.offset += 2;\n    return value;\n  }\n\n  /**\n   * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.\n   */\n  public readUint16(): number {\n    const value = this._data.getUint16(this.offset, this.littleEndian);\n    this.offset += 2;\n    return value;\n  }\n\n  /**\n   * Read a 32-bit signed integer and move pointer forward by 4 bytes.\n   */\n  public readInt32(): number {\n    const value = this._data.getInt32(this.offset, this.littleEndian);\n    this.offset += 4;\n    return value;\n  }\n\n  /**\n   * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.\n   */\n  public readUint32(): number {\n    const value = this._data.getUint32(this.offset, this.littleEndian);\n    this.offset += 4;\n    return value;\n  }\n\n  /**\n   * Read a 32-bit floating number and move pointer forward by 4 bytes.\n   */\n  public readFloat32(): number {\n    const value = this._data.getFloat32(this.offset, this.littleEndian);\n    this.offset += 4;\n    return value;\n  }\n\n  /**\n   * Read a 64-bit floating number and move pointer forward by 8 bytes.\n   */\n  public readFloat64(): number {\n    const value = this._data.getFloat64(this.offset, this.littleEndian);\n    this.offset += 8;\n    return value;\n  }\n\n  /**\n   * Read a 1-byte ASCII character and move pointer forward by 1 byte.\n   */\n  public readChar(): string {\n    return String.fromCharCode(this.readInt8());\n  }\n\n  /**\n   * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.\n   */\n  public readChars(n = 1): string {\n    let result = '';\n    for (let i = 0; i < n; i++) {\n      result += this.readChar();\n    }\n    return result;\n  }\n\n  /**\n   * Read the next `n` bytes, return a UTF-8 decoded string and move pointer\n   * forward by `n` bytes.\n   */\n  public readUtf8(n = 1): string {\n    return decode(this.readBytes(n));\n  }\n\n  /**\n   * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer\n   * forward by 1 byte.\n   */\n  public writeBoolean(value: unknown): this {\n    this.writeUint8(value ? 0xff : 0x00);\n    return this;\n  }\n\n  /**\n   * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.\n   */\n  public writeInt8(value: number): this {\n    this.ensureAvailable(1);\n    this._data.setInt8(this.offset++, value);\n    this._updateLastWrittenByte();\n    return this;\n  }\n\n  /**\n   * Write `value` as an 8-bit unsigned integer and move pointer forward by 1\n   * byte.\n   */\n  public writeUint8(value: number): this {\n    this.ensureAvailable(1);\n    this._data.setUint8(this.offset++, value);\n    this._updateLastWrittenByte();\n    return this;\n  }\n\n  /**\n   * An alias for {@link IOBuffer#writeUint8}.\n   */\n  public writeByte(value: number): this {\n    return this.writeUint8(value);\n  }\n\n  /**\n   * Write all elements of `bytes` as uint8 values and move pointer forward by\n   * `bytes.length` bytes.\n   */\n  public writeBytes(bytes: ArrayLike<number>): this {\n    this.ensureAvailable(bytes.length);\n    for (let i = 0; i < bytes.length; i++) {\n      this._data.setUint8(this.offset++, bytes[i]);\n    }\n    this._updateLastWrittenByte();\n    return this;\n  }\n\n  /**\n   * Write `value` as a 16-bit signed integer and move pointer forward by 2\n   * bytes.\n   */\n  public writeInt16(value: number): this {\n    this.ensureAvailable(2);\n    this._data.setInt16(this.offset, value, this.littleEndian);\n    this.offset += 2;\n    this._updateLastWrittenByte();\n    return this;\n  }\n\n  /**\n   * Write `value` as a 16-bit unsigned integer and move pointer forward by 2\n   * bytes.\n   */\n  public writeUint16(value: number): this {\n    this.ensureAvailable(2);\n    this._data.setUint16(this.offset, value, this.littleEndian);\n    this.offset += 2;\n    this._updateLastWrittenByte();\n    return this;\n  }\n\n  /**\n   * Write `value` as a 32-bit signed integer and move pointer forward by 4\n   * bytes.\n   */\n  public writeInt32(value: number): this {\n    this.ensureAvailable(4);\n    this._data.setInt32(this.offset, value, this.littleEndian);\n    this.offset += 4;\n    this._updateLastWrittenByte();\n    return this;\n  }\n\n  /**\n   * Write `value` as a 32-bit unsigned integer and move pointer forward by 4\n   * bytes.\n   */\n  public writeUint32(value: number): this {\n    this.ensureAvailable(4);\n    this._data.setUint32(this.offset, value, this.littleEndian);\n    this.offset += 4;\n    this._updateLastWrittenByte();\n    return this;\n  }\n\n  /**\n   * Write `value` as a 32-bit floating number and move pointer forward by 4\n   * bytes.\n   */\n  public writeFloat32(value: number): this {\n    this.ensureAvailable(4);\n    this._data.setFloat32(this.offset, value, this.littleEndian);\n    this.offset += 4;\n    this._updateLastWrittenByte();\n    return this;\n  }\n\n  /**\n   * Write `value` as a 64-bit floating number and move pointer forward by 8\n   * bytes.\n   */\n  public writeFloat64(value: number): this {\n    this.ensureAvailable(8);\n    this._data.setFloat64(this.offset, value, this.littleEndian);\n    this.offset += 8;\n    this._updateLastWrittenByte();\n    return this;\n  }\n\n  /**\n   * Write the charCode of `str`'s first character as an 8-bit unsigned integer\n   * and move pointer forward by 1 byte.\n   */\n  public writeChar(str: string): this {\n    return this.writeUint8(str.charCodeAt(0));\n  }\n\n  /**\n   * Write the charCodes of all `str`'s characters as 8-bit unsigned integers\n   * and move pointer forward by `str.length` bytes.\n   */\n  public writeChars(str: string): this {\n    for (let i = 0; i < str.length; i++) {\n      this.writeUint8(str.charCodeAt(i));\n    }\n    return this;\n  }\n\n  /**\n   * UTF-8 encode and write `str` to the current pointer offset and move pointer\n   * forward according to the encoded length.\n   */\n  public writeUtf8(str: string): this {\n    return this.writeBytes(encode(str));\n  }\n\n  /**\n   * Export a Uint8Array view of the internal buffer.\n   * The view starts at the byte offset and its length\n   * is calculated to stop at the last written byte or the original length.\n   */\n  public toArray(): Uint8Array {\n    return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);\n  }\n\n  /**\n   * Update the last written byte offset\n   * @private\n   */\n  private _updateLastWrittenByte(): void {\n    if (this.offset > this.lastWrittenByte) {\n      this.lastWrittenByte = this.offset;\n    }\n  }\n}\n"],"names":["scope","FastTextEncoder","utfLabel","RangeError","FastTextDecoder","options","fatal","Error","Object","defineProperty","prototype","value","encode","string","stream","pos","extra","len","length","at","tlen","Math","max","target","Uint8Array","charCodeAt","update","set","slice","decode","buffer","bytes","out","byte1","push","byte2","byte3","codepoint","String","fromCharCode","apply","window","self","this","decoder","TextDecoder","exports","encoder","TextEncoder","str","IOBuffer","data","dataIsGiven","ArrayBuffer","lastWrittenByte","byteLength","offset","dvOffset","isView","byteOffset","littleEndian","_data","DataView","_mark","_marks","n","pop","undefined","seek","available","newLength","newArray","readUint8","getInt8","getUint8","i","readByte","getInt16","getUint16","getInt32","getUint32","getFloat32","getFloat64","readInt8","result","readChar","utf8_1","readBytes","writeUint8","ensureAvailable","setInt8","_updateLastWrittenByte","setUint8","setInt16","setUint16","setInt32","setUint32","setFloat32","setFloat64","writeBytes"],"mappings":"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"}